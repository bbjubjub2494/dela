package byzcoin

import (
	"go.dedis.ch/dela"
	"go.dedis.ch/dela/blockchain"
	"go.dedis.ch/dela/consensus/viewchange"
	"go.dedis.ch/dela/ledger/byzcoin/types"
	"go.dedis.ch/dela/ledger/inventory"
	"go.dedis.ch/dela/serde"
	"golang.org/x/xerrors"
)

// txProcessor provides primitives to pre-process transactions and commit their
// payload later on.
//
// - implements blockchain.Reactor
type txProcessor struct {
	types.MessageFactory

	inventory inventory.Inventory
}

func newTxProcessor(f types.MessageFactory, i inventory.Inventory) *txProcessor {
	return &txProcessor{
		MessageFactory: f,
		inventory:      i,
	}
}

// InvokeValidate implements blockchain.Reactor. It returns the payload if the
// validation is a success. In that case, the payload has been staged in the
// inventory and is waiting for a commit order.
func (proc *txProcessor) InvokeValidate(data serde.Message) (blockchain.Payload, error) {
	blueprint, ok := data.(types.Blueprint)
	if !ok {
		return nil, xerrors.Errorf("invalid message type '%T'", data)
	}

	payload := types.NewBlockPayload(nil, blueprint.GetTransactions())

	page, err := proc.process(payload)
	if err != nil {
		return nil, xerrors.Errorf("couldn't stage the transactions: %v", err)
	}

	payload = types.NewBlockPayload(page.GetFingerprint(), payload.GetTransactions())

	return payload, nil
}

// InvokeCommit implements blockchain.Reactor. It tries to commit to the payload
// as it should have previously been processed. It returns nil if the commit is
// a success, otherwise an error.
func (proc *txProcessor) InvokeCommit(p blockchain.Payload) error {
	var root []byte

	switch payload := p.(type) {
	case types.GenesisPayload:
		page, err := proc.setup(payload.GetRoster())
		if err != nil {
			return xerrors.Errorf("couldn't stage genesis: %v", err)
		}

		if page.GetIndex() != 0 {
			return xerrors.Errorf("index 0 expected but got %d", page.GetIndex())
		}

		root = payload.GetRoot()
	case types.BlockPayload:
		_, err := proc.process(payload)
		if err != nil {
			return xerrors.Errorf("couldn't process: %v", err)
		}

		root = payload.GetRoot()
	default:
		return xerrors.Errorf("invalid message type '%T'", p)
	}

	// If the root generated by the processing of the payload is not correct
	// then the page won't be committed.
	err := proc.inventory.Commit(root)
	if err != nil {
		return xerrors.Errorf("couldn't commit to page '%#x': %v", root, err)
	}

	return nil
}

func (proc *txProcessor) setup(roster viewchange.Authority) (inventory.Page, error) {
	page, err := proc.inventory.Stage(func(page inventory.WritablePage) error {
		err := page.Write(rosterValueKey, roster)
		if err != nil {
			return xerrors.Errorf("couldn't write roster: %v", err)
		}

		return nil
	})
	if err != nil {
		return nil, xerrors.Errorf("couldn't stage page: %v", err)
	}

	return page, nil
}

func (proc *txProcessor) process(payload types.BlockPayload) (inventory.Page, error) {
	page := proc.inventory.GetStagingPage(payload.GetRoot())
	if page != nil {
		// Page has already been processed previously.
		return page, nil
	}

	page, err := proc.inventory.Stage(func(page inventory.WritablePage) error {
		for _, tx := range payload.GetTransactions() {
			dela.Logger.Trace().Msgf("processing %v", tx)

			err := tx.Consume(page)
			if err != nil {
				return xerrors.Errorf("couldn't consume tx: %v", err)
			}
		}

		return nil
	})
	if err != nil {
		return nil, xerrors.Errorf("couldn't stage new page: %v", err)
	}

	dela.Logger.Trace().Msgf("staging new inventory %#x", page.GetFingerprint())

	return page, nil
}
