package controller

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/x509"
	"io/ioutil"
	"math"
	"os"
	"path/filepath"
	"time"

	"go.dedis.ch/dela"
	"go.dedis.ch/dela/cli"
	"go.dedis.ch/dela/cli/node"
	"go.dedis.ch/dela/core/store/kv"
	"go.dedis.ch/dela/mino"
	"go.dedis.ch/dela/mino/minogrpc"
	"go.dedis.ch/dela/mino/minogrpc/certs"
	"go.dedis.ch/dela/mino/router/tree"
	"golang.org/x/xerrors"
)

// Minimal is an initializer with the minimum set of commands.
//
// - implements node.Initializer
type minimal struct{}

// NewMinimal returns a new initializer to start an instance of Minogrpc.
func NewMinimal() node.Initializer {
	return minimal{}
}

// Build implements node.Initializer. It populates the builder with the commands
// to control Minogrpc.
func (m minimal) SetCommands(builder node.Builder) {
	builder.SetStartFlags(
		cli.IntFlag{
			Name:  "port",
			Usage: "set the port to listen on",
			Value: 2000,
		},
	)

	cmd := builder.SetCommand("minogrpc")
	cmd.SetDescription("Network overlay administration")

	sub := cmd.SetSubCommand("certificates")
	sub.SetDescription("list the certificates of the server")
	sub.SetAction(builder.MakeAction(certAction{}))

	sub = cmd.SetSubCommand("token")
	sub.SetDescription("generate a token to share to others to join the network")
	sub.SetFlags(
		cli.DurationFlag{
			Name:  "expiration",
			Usage: "amount of time before expiration",
			Value: 24 * time.Hour,
		},
	)
	sub.SetAction(builder.MakeAction(tokenAction{}))

	sub = cmd.SetSubCommand("join")
	sub.SetDescription("join a network of participants")
	sub.SetFlags(
		cli.StringFlag{
			Name:     "token",
			Usage:    "secret token generated by the node to join",
			Required: true,
		},
		cli.StringFlag{
			Name:     "address",
			Usage:    "address of the node to join",
			Required: true,
		},
		cli.StringFlag{
			Name:     "cert-hash",
			Usage:    "certificate hash of the distant server",
			Required: true,
		},
	)
	sub.SetAction(builder.MakeAction(joinAction{}))
}

// OnStart implements node.Initializer. It starts the minogrpc instance and
// injects it in the dependency resolver.
func (m minimal) OnStart(ctx cli.Flags, inj node.Injector) error {

	port := ctx.Int("port")
	if port < 0 || port > math.MaxUint16 {
		return xerrors.Errorf("invalid port value %d", port)
	}

	rter := tree.NewRouter(minogrpc.AddressFactory{})

	addr := minogrpc.ParseAddress("127.0.0.1", uint16(port))

	var db kv.DB
	err := inj.Resolve(&db)
	if err != nil {
		return err
	}

	certs := certs.NewDiskStore(db, minogrpc.AddressFactory{})

	key, err := loadOrCreateKey(filepath.Join(ctx.Path("config"), "cert.key"))
	if err != nil {
		return err
	}

	opts := []minogrpc.Option{
		minogrpc.WithStorage(certs),
		minogrpc.WithCertificateKey(key, key.Public()),
	}

	o, err := minogrpc.NewMinogrpc(addr, rter, opts...)
	if err != nil {
		return xerrors.Errorf("couldn't make overlay: %v", err)
	}

	inj.Inject(o)

	dela.Logger.Info().Msgf("%v is running", o)

	return nil
}

// StoppableMino is an extension of Mino to allow one to stop the instance.
type StoppableMino interface {
	mino.Mino

	GracefulStop() error
}

// OnStop implements node.Initializer. It stops the network overlay.
func (m minimal) OnStop(inj node.Injector) error {
	var o StoppableMino
	err := inj.Resolve(&o)
	if err != nil {
		return xerrors.Errorf("injector: %v", err)
	}

	err = o.GracefulStop()
	if err != nil {
		return xerrors.Errorf("while stopping mino: %v", err)
	}

	return nil
}

func loadOrCreateKey(path string) (*ecdsa.PrivateKey, error) {
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		priv, err := ecdsa.GenerateKey(elliptic.P521(), rand.Reader)
		if err != nil {
			return nil, xerrors.Errorf("couldn't generate the private key: %+v", err)
		}

		data, err := x509.MarshalECPrivateKey(priv)
		if err != nil {
			return nil, err
		}

		file, err := os.Create(path)
		if err != nil {
			return nil, err
		}

		_, err = file.Write(data)
		if err != nil {
			return nil, err
		}

		return priv, nil
	}

	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}

	data, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, err
	}

	priv, err := x509.ParseECPrivateKey(data)
	if err != nil {
		return nil, err
	}

	return priv, nil
}
