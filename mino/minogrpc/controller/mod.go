package controller

import (
	"encoding/json"
	"fmt"
	"time"

	"go.dedis.ch/fabric/cmd"
	"go.dedis.ch/fabric/mino/minogrpc"
)

type minimal struct{}

// NewMinimal returns a new controller to start an instance of Minogrpc.
func NewMinimal() cmd.Controller {
	return minimal{}
}

func (m minimal) Build(builder cmd.Builder) {
	cli := builder.Command("minogrpc")

	cli.Command("token").
		Description("generate a token to share to others to join the network").
		Flags(
			&cmd.DurationFlag{
				Name:  "expiration",
				Usage: "amount of time before expiration",
				Value: 24 * time.Hour,
			},
		).
		Action(tokenAction{})

	cli.Command("join").
		Description("join a network of participants").
		Flags(
			&cmd.StringFlag{
				Name:     "token",
				Usage:    "secret token generated by the node to join",
				Required: true,
			},
			&cmd.StringFlag{
				Name:     "address",
				Usage:    "address of the node to join",
				Required: true,
			},
		).
		Action(joinAction{})
}

func (m minimal) Run(inj cmd.Injector) error {
	o, err := minogrpc.NewMinogrpc("127.0.0.1", 2000, nil)
	if err != nil {
		return err
	}

	inj.Inject(o)

	return nil
}

type tokenRequest struct {
	Expiration time.Duration
}

type tokenAction struct{}

func (a tokenAction) Prepare(ctx cmd.Context) ([]byte, error) {
	req := tokenRequest{
		Expiration: ctx.Duration("expiration"),
	}

	buffer, err := json.Marshal(req)
	if err != nil {
		return nil, err
	}

	return buffer, nil
}

func (a tokenAction) Execute(req cmd.Request) error {
	dec := json.NewDecoder(req.In)

	input := tokenRequest{}
	err := dec.Decode(&input)
	if err != nil {
		return err
	}

	// TODO: implements in minogrpc
	fmt.Fprintf(req.Out, "token-abc\n")

	return nil
}

type joinAction struct{}

func (a joinAction) Prepare(ctx cmd.Context) ([]byte, error) {
	return nil, nil
}

func (a joinAction) Execute(req cmd.Request) error {
	return nil
}
